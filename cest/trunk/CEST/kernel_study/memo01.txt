お世話になります。

小川清＠名古屋市工研です。

議事録にはなりませんが、
個人的なメモです。

もうすこし、整理しなおしたら、
メールしなおそうと思いますが、
どのMLに投げるといいでしょうか？

#個人メモ　電源ケーブルを持参すること。
#名簿以外に高専の学生３人
#9/13日　時間を早める
#予備日
#豊田高専　黒田, 桜井
#宮城高専　松田

8/20 memo 小川清　2001.8.24

全体の感想
ITRONの標準化は、必要に応じてという感じで、
形式論理的ではないところがよさそう。
必要なところを厳密にしている。

1 優先度と優先順位
　優先度：優先するかどうかを判定するために用いるの値。
ここでは、整数で決めた優先するかどうかを判定するため、同じ優先の程度を持ち、時
間的に決める「優先順位」とともに用いる値で、値が小さい方が、優先順位が高い。
　優先順位：優先するかどうかを判定するために用いる相互の順序関係
　ここでは、同じ優先度をもつ集合の中でのみ定義し、時間が早いものが優先順位が高
いものとする。

２　移植性
ソフトウェア移植性向上は、他の目的よりも、より抽象度が高いか、
より間接的であると考えるとよいのではないか。
　ソフトウェア技術者が、一度覚えたことを、そのまま使えるという話を、
前面に出すとよい。
　OSの機能を統一
　設計資産は残る
　一回覚えたものがそのまま使える
　バージョン４が、バージョン３で、どうなのか。　バックワードコンパチはない。

質問１　バックワードコンパチを少しでも確保するためのマクロは作っているか？
　
どちらにしろ、新しい版は、新しいハード、新しい機能があるので、チューニングし直
す。

3　タスクの状況
　これが本質かどうか。現在は、これでよい。
実行可能状態redy
実行状態running
待ち状態dormant
二重待ち状態waitint
強制待ち状態suspend
休止状態
未登録状態
　今回のToppersではない。

suspend_task
　使うのが難しい。
　DEBUGでは使う。
　例外処理をしている。
　他人から待てと言われている。
　仕様上は、２回以上、suspendできる。
　counterは、上限が１回。２回かけるとエラーになる。
　サスペンドはあまり使わない。
resume_task
  待ちにしたタスク以外でも、resumeできる。

いくつも起こしておけるか。
　待ちは重ならない。

どの機能が使われそうか。
　こういう使われ方をするから、この機能は入れておこう。

UNIXとの対比
　全部起こして。
　キューにいるのを起こすというのは、、、

ITRON　
ねらったタスクだけ起こす。
　
待ちは、いろんな待ちがある。

タスク強制待ち

dispatch、preemptは、システムコールがない。
それ以外のシステムコールはある。
sleep

作った状態でスタックを設定する。
休止がある。

スケジューリング規則
　ディスパッチとプリエンプトする。

4用語
priemptive
priemptable
priempti???

5
First Come First Served
実行できる状態（実行可能状態、実行状態）に、来たのが早い状態。

あるタスクが、自分で少し処理して、
自分自身が待ちに入ることにより、
他のタスクが実行できるようにする。

6 
スタンダードプロファイル
　他のプロファイルは？

ハイエンドの１６ビット
３２ビットプロセッサ

C int 16bit, 32 bit

スタンダードプロファイル
　ビット数をさらに
　64ビット

32bit profile
64bit profile

7
ITRONの標準化は、弱い標準化である。
それで、困ったことはなさそう。
現実に必要のないことを、標準化しても意味がない。


優先度の数、
タスクの上限
どれを想定して作ればよいか。

standard profileを、４で作ったのは、
標準化の必要性があったから。

8
静的API
　サービスコール
　　システムコンフィグレーション
　ソフトウェア部品で共通に利用するもの

10
オブジェクト：定義していない。数え上げれば、言える。
　カーネルオブジェクト
　タスク
　セマフォ

カーネルが管理している単位をオブジェクト
　操作対象としている資源。
　システムコールで第一引数に取っている。

12
Wが３２ビットなのは、トロンチップが３２ビットだったから。

３
コンテキスト(context)
　スタック、レジスタ、そのタスクを実行するのに必要な情報
　システムのモードか、ユーザのモードか
　状態
　制約条件
　切り替わらないレジスタ
　　ここでは、タスクのコンテキスト
　レジスタが、たくさんある場合、ハードウェアの制約。
　特定のタスク用のレジスタという実装もありえる。 

ディスパッチ、コンテキストスイッチ

タスクコンテキスト

拡張サービスコールルーチンは、
タスクからよばれれば、タスクコンテキスト
非タスクコンテキストは、非タスクコンテキスト

実行状態
　ただし書き
　　非タスクコンテキストを実行している場合には、
　　その前に実行していたものが、実行状態とする。

コンテキスト
　スタックポイント
　
非タスクコンテキスト
　タスクでないもの（非タスク）のコンテキスト
　割り込みのスタックを使う。

カーネルは実装によって違うので、
　
スリープタスク
　割り込みハンドラから

タスク例外処理ルーチン
　long jump

CPU例外ハンドラ

13 割り込みと例外
割り込み
　プロセッサにより違いがある。
　カーネルで、
　移植性があがらないから、割り込みサービスルーチン
　
ITRONの３では、ユーザのハンドラへ飛んでいった

IRC
　レベルトリガ
　　０だったら割り込みを要求していない
　　１だったら割り込みを要求する
　エッジトリガ
　　パルスが０から１になったら

レベルトリガでは、
　割り込みサービスルーチンが割り込み要求をクリアする。

エッジトリガでは、
　割り込みハンドラで、クリアする。
　IRCによる。

IRCの割り込みサービスフラグのクリアは、
　IRCにそのような機能がある場合。

割り込みハンドラ
　OS
　CPU
　コントローラ（IRC)
　対象デバイス

E社、CPUで割り込みレベルを持っていない場合は、IRCが割り込みレベルを持っている
場合が多い。
割り込みハンドラ

割り込み要因
割り込み要求
　割り込み要求入力ラインに複数のデバイスが接続されている。

どちらかを持っていればよい。
　割り込みハンドラか、割り込みサービスルーチン
　今回は、割り込みサービスルーチンは持っていない。
　実装依存。
割り込みハンドラは１つなので、
　DEF_INH

組み込みサービスルーチンは、複数登録できる。
　attachという名前は、追加できるから。
　静的APIでATT_ISR
 動的には、アタッチできない。

plag and play
 予めアタッチしておくか？

ハードウェア構成が動的に変わる場合には、
　割り込みだけでなく、タスク、セマフォも足したいのではないか？

タスク例外処理要求

orが取られて、
１と２の例外が発生すると、
３が実行される。

タスク例外
　シグナル
　タスク処理例外は、そのタスクで、同時に２つ起きることは想定していない？

CPU例外も、CPU例外ハンドラで処理できるようにする。
　UNIXのようなOSではなく、直接システムに影響を与える処理ができるようにする。

０を弾く。
わかっていれば、処理できる。わかっていないから、例外だ。

SHは、そもそも割れない
奇数番地をアクセスして、例外を発生させる。
０では割れない。

インテルは、割り込みも例外も割り込みと呼んでいる。
モトローラは、どちらも例外と呼んでいる。

内部から呼ぶのを例外で、外部から割り込み。

割り込みと例外は別のもの。

今実行しているものと関係なく、やってくるのが割り込み。
今実行しているものと関係しているのは例外。

タスク実行中に０割
そのタスクをスリープタスクすることがありえるので、
タスクコンテキストで実行する。

ページ例外

１３　ディスパッチ
非タスクでは、自タスクという概念がないので、
自タスクを指定することができない。

昔のITRONは、遅延ディスパッチと呼ぶ
割り込みハンドラが動いている間は、
ディスパッチャは動かない

処理の優先順位の優先度は、
呼び出し関係を表していない。

ディスパッチャが、スリープタスクを呼ぶ
スリープタスクが、ディスパッチャを呼ぶ

CPUロック状態にするシステムコール
CPUロック状態を解除するシステムjコールがある。

CPUロック状態とは、割り込み禁止状態

ディスパッチ禁止状態は、
割り込みは入るが、ディスパッチは起こらない。

ディスパッチ保留状態
　ディスパッチを保留すべき状態
