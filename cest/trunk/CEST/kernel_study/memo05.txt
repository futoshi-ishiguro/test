カーネル勉強会第５回目　9/3　メモ　小川清

今、函館なので、今日は欠席します。
#斉藤さんがメモを取られたら、個人宛でも結構ですので、
#送ってください or 石川さんにお願いするか、、、　> saito

個人的なメモ
ソースコードを読まずに、内容がわかるか？
すべてのソースコードを読むと、そのプロジェクトで何が問題かの半分くらいがわかる
気がする。
ソースコード（試験のためのコード、開発のために作ったツールを含む）を見ると、ど
のプロセスがきちんと働いているか見える。
CISCだとアセンブラのソースを読んで意味がわかり、RISCだとアセンブラのソースの意
味がわかりにくいか？
　個人的には、CPUの特権モードの仕組みを理解していなので、CISCの方がわかりにく
い部分がある。
　RISCだと、特定のアルゴリズムの処理で、その入力の制約条件、出力の制約条件がか
かれていないと、実際には何をしているのかわかりにくい場合がある。

ソースコードを読むときの読み方
　１　ヤマハの方がされたように、自分の理解をコメントし、ソースコードを書いた人
にレビューしてもらうのは、一つの方法。
#Vz editorの移植の際に、そういう方法を取りました。
2 　ソースコードが想定している入力の条件、出力の条件がかかれていなければ、
　上限、下限、あるいはそれ以外の入力、出力の制限があるかどうかを実際に動かして
みながら確かめ、それをソースコードにコメントとして書くとともに、試験事例として
、ソースコードともに、ソースコード管理システムに登録する。
　想定する入力の条件、出力の条件がかかれていれば、その条件内で、想定した動作を
するか確認し、同様の手続きを取る。
　場合によっては、試験をするためのプログラムを書き（スクリプトを含む）、それも
ソースコードとともに管理する。
＃試験研究機関なので、本当は、こういう仕事をしなければならないのですが、
#これまでは、さぼってきました。
#現在は、MosquitoNetというMobileIPの実装に対して、このアプローチで
#ソースを読んでいます。その内容は、１１月に豊橋技科大学開催される電気関係学会
#東海支部で発表予定です。
３　各部分の最適化を考え、最適化の方法を考える。そのソースコードを読んだり、む
ためのツール、最適化のためのツールを作ってみる。
　NOPが、タイミングを取るために入っているのか、コンパイラの性能か、処理の安全
のためか、データの境界設定のためか、判定して、自動的にコメントを入れたりする。
#通信ソフトを理解する際に、ディスアセンブラ＋ジャンプ最適化ツールを作ったこと
があります。
４　別の言語、別のCPU、別の機械に移植してみて、言語依存部分、CPU依存部分、それ
以外のハードウェア依存部分を識別する。
#Cコンパイラを理解するときに、パスカルで書かれたCコンパイラを、C言語に移植しな
がら、C言語を理解しました。
#VZエディタを理解する際に、PC9801以外に移植しながら、理解しました。

JSP
１　ヘッダファイルとCファイルのコメントの書き方
２　レビューアとして、全体を理解している高田先生が見ている。
　今回の勉強会も、共同レビューの一つ
３　CPU依存部と、共通部
　新しいCPUが出れば、この境界は一意にはできない？
　共通部分であっても、CPUに依存する部分は、IFDEFで逃れている？
４　ソースコードの管理
頭の中に、ハードウェア・コンピュータ（CPU）、OS、コンパイラが入っていないと、
ソースコードのレビューができない。

どういう関数は、どういう目的で使われているか
その目的では、どういう制約があるか。
Standard profileは、その制約条件のセット

スタンダードプロファイルの意味は、その上で動く事例数個をもとに、その値の意味が
わかるところと、原理的に処理を早くするために必要なところがあるのか？

ある制約条件可で、そのプログラムがどういう機能を果たすか。
それでよいかどうかを、どうやって判断するか。

１　その分野の経験のあるプログラマでは、過去の経験に照らして、必要な処理をして
いるか、　不具合が出る場合を、うまく処理するようになっているかを見る。
２　その分野の経験のないプログラマでは、自分の得意分野との対比で、どのような対
比がよいかを議論しながら考え、この方法でよいかを確認している。

実際に起こりえる場合を想定して、どの場合に、どうなるかを考えている。
起こると困るが、確率が低い事象を、どのような方法で回避するか。
必ず起こることと、

状態遷移図を書いても、その遷移が起こりえるか、起こり得ないかは、
原理、実験、経験による。
内部処理で状態遷移が変わる場合には、さらに詳細に変わる
タイムアウトによる処理の場合は？

CHECK_TSKCTX_UNL();
は、この関数を終了する可能性があるのか？

メモ

.hに、外から見た仕様をコメントで書く
.c は、内部処理についてコメントで書く

ブールを関数は、何を返すか。
Enadsp
ディスパッチして欲しいときTRUEを返す。

非タスクコンテキストだけ、request flagを使う。

CHECK_TSKCTC_UNL()

Act_taksでは、request flagを触っていない。
Iact_taskで。

いますぐにディスパッチできないときに、
そのフラグを見て、ディスパッチする。

静的API
　コンパイル時に作り、動的に実行しない。
　あらかじめ決めているものを先に作る。
　System configuration fileを作る。
　タスクを生成するオーバヘッドを減らす。

６通りの状態以外に、過渡的な状態がある。
Make_runnable
 が実行して、他のものが働いて、
make_dormant
過渡的な状態
　外から見えない１瞬になるのは、考慮しないでよいのでは？
　外から見える過渡的な状態があるかどうかは、、、
割り込みが動いている状態は、redy, runのいずれか。

JSPではない設定で、非タスクコンテキストでサービスコールした場合に、起こる可能
性がある？

サービスコールは、割り込み禁止
　機能範囲内

　メッセージが不定長の場合？？？

Iがついたのが、非タスクコンテキストで呼べるもの。
中でクリティカルセクションを
セマフォ、割り込み禁止を作る。
再入可能か？

システムコール、副作用がある。

今のカーネルはプリエンプティブではない。
テストの組み合わせが多くなる。
SHでは、
効率が悪い。
プロセッサ依存部で、ビット幅を変えられるようにする。
32ビットCPU
 TBIT_TCP_TSTAT 8にしている。
 TBIT_TCB_PRIOTIRYも８にしている。
どちらにしろ32ビット使うので、８ビットづつの方が処理が早い。

実行できる状態（REDYとRUN）

デリートされたエントリはどうするのか？
どうもしない。
フリーリストを作りたければ、そのキューをもう一つ作る。
Dormantはキューにつながっていない。

TRONチップでは、queue_insert, queue_deleteは一命令

ラウンドロビンではない。
FirstComeFirstServed

CPU_BITMAP_SEACH
は、CPUにこの命令があれば、CPU依存部で定義している。

CPU非依存部とは、ＣPUがハードウェアで同じことをできる場合も含む。

１６だからこれでいいのでは、２５６個だと、
違う方法がいい

Act_task
Iact_task
は、似た処理をしているので、どちらがどちらも呼んでよいかもしれないが、
スタンダードプロファイルでは、別にすることにしている。

Actcnt =tcb->actcnt ?1:0;
この行は何？
型変換を含んだ、代入。キャストだと、長い違う処理をするといや。

関数を別にしたのは、
alloca()
何ワードか保存して、
activate contextを呼ぶと、壊される。
確保した領域を壊される。
ローカル変数がないのでよいが、
ローカル変数があるとまずよいだろう。

そこで、別の関数にして、さらにその下で実行していれば、
コンパイラが想定外のことをしていても、うまくいくようなおまじない？

変わる可能性があるものは、ロックしてからやる。
タスクコンテキストでは、元に戻るため、
CHECK_TSKCTX_UNL()
がロックされていないくてもよい。

状態遷移図
　×はありえない。
JIPC
全部の状態を確かめる機能があるか。

CPUによっては、タスクコンテキストと非たくすコンテキストで同じ
ロック方式でよい場合がある。

スタンダードプロファイルでは１は、１ｍ秒
−１は、永久待ち

バージョン４は実装依存
JSPは、割り込み

キャンセル
周期処理
　絶対やってほしい
　できればやりたい

サスペンドは、自分を止める
ディスパッチ禁止のときは、


タスクを作る中途半端な状態

enable dispatch
他のタスクに行かないのをdisable dispatch（割り込みはよい。）

カーネルがディスパッチ禁止にしたいときは、disable dispatchを流用してもよい。
責任持って、もどしてね。
SHの実装では使っていない。

Winfo
　次回にも出てくる。

Assert(tmout==TMO_FEVR)
 条件判断として、条件が満たすはず。そうでなければ、エラーにする。（デバッグ時
には、ログを残して止まる）
