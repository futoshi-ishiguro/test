小川清＠名古屋市工研です。

勉強になった点
1 　理解が正確化どうか、実態がどうか、調査すると面白い点
CPUの設計上の方針を理解したり、物理的な実装を知ることにより、
どういう処理が高速であるか、安全であるかを理解することが大事そう。
たとえば、CPUの設計上、積和演算の結果を、レジスタに出力できる場合、その結果を
入れるレジスタは、書き込み可能なものにするか、読み出ししかできないようにするか
は、設計の方針によるかどうか。
ステータスレジスタは、回路の状態をレジスタの大きさにそろえて結果を出すが、書き
込み可能なレジスタに出すか、回路の状態を直接取れるようにするかは、設計の方針に
よるかどうか。

２　メモリ上の配置
ROM
_ _text
text
_ _etext
	rodata
_ _ idata_start
	.dataと同じもの
_ _ idata_end
	空き（？）
RAM
_ _ data_start
	.data
_ _ bss_start
	.bss
_ _ bss_end
	空き（？）

連絡事項
http://www.ertl.jp/CEST/kernel_study
user: kernel_study
passwd: shiryou

メモ
priemptable, priemptible

日立　R15、SH1,2
ハードウェアスタック
R15に縛られる必要がない。

OS、開発環境、スケジューリング、

内臓RAMキャッシュ
７７０９　アドレス変換されない。

開発環境

インラインアセンブラ

オープンソース、ロイヤリティフリー
BSD、（２）の（ｂ）がある。
GPLを選択できるようにする方向性。
Configuratorをリンクさせようとすると。
GPLを、まるごと認める。
デュアルライセンス、perl, 
qt
配布しようとすると、
glibc
ライブラリ
LGPL
結合の密具合
GCCが出したアセンブラのソースコード
コンフィギュレータ
特にしない。
自動翻訳ソフト

Yacc、bison
GCC, ELF

GDBスタブ
　シリアルに情報を出す。
 100, STUB,

ROMライタで
　Toppers, linux-SH スタブがソースコードである。
　スタブは取るからいいだろう。
　
ROMとフラッシュに変わる。
　フラッシュに書き込むことができる。
　エプソンはCFに書き込む。
　ダウンローダよりもよい。

Cpu_config.h
# define MAX_IPM
スタブを使う場合　１４
スタブを使わない場合　１５

SUPPORT_CHG_IPM
IPM対応でオーバヘッドがある。
#defineで取捨選択可能

CPU例外発生時のPCの値はインクリメントされる。
戻る前に、２増やす？コードを読むこと。

レジスタバンク１のr0は、スタブが使うため、利用者は使わないように。

リトライ型だと、もう一度エラーが起きる。
原因を取り除くか、
０割をロード命令に変えた、
サンプルプログラムを動かすために、パッチをあてている。

GCCが、GBRを使う場合は、保存する。-mhitachiをつけても関係ない。

Caller saved register
　必ず使うものは、予め保存する。
Callee saved register
 呼ばれた側が保存する。この場合は、自分が使うものだけ保存する。

ディスパッチが保存するかどうか。
　割り込まれた場合は、何を使うかわからないので、保存する。

MAC(multiple accumulation counter), 

レジスタ
ハードウェアを作る。
専用レジスタ
汎用レジスタに内部でコピーする。
RISCから、

コンパイラ、
アーキテクチャハンドブックを読む。
実装依存

MIPS
読み出し専用で、ストアできない。
初期値を入れたい。

積和、書けたほうがよい。

リンカスクリプト
 AT　場所を置き換える。
 ALIGN バイト境界、ワード境界を合わせる。
PROVIDE 定義してなければ、この値を使う。

P12
現在
Cmp/hi r1,r2
Add #4, r0
Bt start_4
遅延スロット
Cmp/hi r1,r2
Bt/s tart_4
Add #4, r0

P11
現在
Start_2
Mov.l r2.@r0
Add #4,r0
Cmp/hi ro,r1
Bt start_2
遅延スロット
Mov.l r2.@r0
Start_2
Add #4,r0
Cmp/hi ro,r1
Bt/s start_2
Mov.l r2.@r0

Stub の実行が先頭から。
STUBのりんかスクリプト

毎回実行番地が変わるといやな。

何が「.」を定義しているか。
リンカは順番に位置付ける。

マクロでスタートオブジェクト

エプソンのは、頭に特殊なものを置くものがある。
CFに、バイナリを入れて、ブータがROMを呼ぶので、
ブータが呼べるヘッダを。

ソフトウェアinit fookで、
ライブラリの初期化が必要なものは、ここで初期化する。

_をつけるのがC
アンダバーをつけて、Cの関数として使うには、_をつける。

アセンブラのラベルと、Cのラベル
GNUでも設定によって違う。
１バイトのキャラクタ

スタートアップモジュール、マクロで
アンダーバーを吸収

GAS
GCC

GASを使っている。
リンカ、デバッガはGNU

ROMモニタを捨てる。

ハードウェア依存の初期化

STUB側でやる。
同じようなコードを、持ってくる。

ハードウェアを初期化しないと、RAMもアクセスできない。
バス、シリアル、タイマ、キャッシュ、

どこまでをスタートアップに入れるか。
ボード依存の初期化をしない。

Ifdefで、STUBの設定を。

Activate task
Activate_rでは、
TCBに入っているので、
Activate_r

Make offset
面倒くさい。

先に積んだ方が、楽だ。

順番が不思議かもしれないが、68000ではそうしている。

Activate_r優先度が高くなり、実行されるときに。

カーネルを設計する場合、
カーネルコンテキストかどうか、
CPUをロックしているかどうか
を見分けれる。

CHANGE　IPM　１４に変えると、
微妙。

タスクの中で、マスクを切り替えることはない。
CHG＿IPMは、書き換える。
GET_IMPで、前の状態がわかる。
そういう仕様。

Lock, unlockは、履歴を覚えない。

カーネルを書く人は、CPUロック状態でlock_cpuを呼ばない。
逆に、CPU依存部を書く人は、lock_cpuは、CPUロック状態で呼ばないので、再入は考え
る必要はない。

I_lock_cpu()
Intmaskをネストさせなくてもよい理由は、CPUをロックしているから。

ロックする隙間が危ない。

Disintでも、current_intmaskでもcurrent_srを呼んでいるので、プログラムを美しく
するには、値を持って、実施してもよいのでは。
#Current_srを読むこと。

前の値を残して、スワップすれば、、、
いきなり書くとか、読むとかになっていない。


ロック状態かわからない場合は、sense lockを呼ぶことになる。

保存
実行するタスクを選ぶ
復帰

割り込みハンドラ
　タスクをセットしない場合もあるか。
クロックをアップするが、何もしないものもある。

カーネル設計テキスト
　アイドルタスクを導入しない。
　RAMの使用量が増える。

絶対眠らないアイドルタスク
　必ず動けるので０チェックがいらない。
　０チェックはたいしたことはない。
　０チェックよりも、早く切り替えたい。

　TCB32バイト。
　アイドルタスクの初期化。いやだ。
　
Exit_and_dispatch
 呼ぶ前に、後始末する。前の処理は、CPU非依存のところでやっている。

カーネルの初期化処理を、割り込みで処理する。
初期化処理は、非タスクコンテキストと思わせる必要がある。

　
割り込みハンドラの入り口で保存してから飛んでくるから、
割り込みハンドラ出口処理で、「残り」を保存する。

ディスパッチャの作り方
　一つのタスク、
　　ret_int, 
    dispatch, dispatcher_1, 
    ret_int, dispatcher_1
    dispatch, dispatch

保存のされ方が違う。
　MACH、MACL,GBRがどう保存されたかが違う。
　自分を復帰するルーチンが保存されている。
　
Activate_r:復帰しなくてもよい。
Ret_int_r
Dispatch_r:
ごみを戻さない。
時間をかせぎたい。

Formatを決めておく。
戻し方は一定。

自分の意志で手放している。
そのつもりで作っている。

Caller saved register, 
割り込みの頭で保存するように変更する。

自分からディスパッチしたときは、ROからR7まではどこにも存在していない。
デバッガに、後から、R0からR7までは、

割り込みが起きても、優先順位が低いものは、
runtskとschedtskは、変わらないので、すぐにリターン

makeoffsetは次回。
