＜kernel/check.c＞---------------------------------------------------
/*
 *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
 */
#define CHECK_TSKCTX_UNL() {					\
	/**
	 ** sense_context()
	 **   TRUE => 非タスクコンテキスト
	 **   FALSE => タスクコンテキスト
	 **/
	if (sense_context() || t_sense_lock()) {		\
		return(E_CTX);					\
	}							\
}

#define CHECK_INTCTX_UNL() {					\
	if (!sense_context() || i_sense_lock()) {		\
		return(E_CTX);					\
	}							\
}

/*
 *  タスク優先度のチェック（E_PAR）
 */
#define CHECK_TPRI(tpri) {					\
	if (!VALID_TPRI(tpri)) {				\
		return(E_PAR);					\
	}							\
}

#define CHECK_TPRI_INI(tpri) {					\
	if (!(VALID_TPRI(tpri) || (tpri) == TPRI_INI)) {	\
		return(E_PAR);					\
	}							\
}

#define CHECK_TPRI_SELF(tpri) {					\
	if (!(VALID_TPRI(tpri) || (tpri) == TPRI_SELF)) {	\
		return(E_PAR);					\
	}							\
}

/*
 *  呼出しコンテキストのチェック（E_CTX）
 */
#define CHECK_TSKCTX() {					\
	if (sense_context()) {					\
		return(E_CTX);					\
	}							\
}

#define CHECK_INTCTX() {					\
	if (!sense_context()) {					\
		return(E_CTX);					\
	}							\
}


＜kernel/task.h＞----------------------------------------------------
/*
 *  タスク優先度の内部表現・外部表現変換マクロ
 */
#define INT_PRIORITY(x)		((UINT)((x) - TMIN_TPRI))
#define EXT_TSKPRI(x)		((PRI)(x) + TMIN_TPRI)


＜kernel/task.c＞----------------------------------------------------
/*
 *  レディキューの回転
 *
 *  最高優先順位のタスクを更新するのは，最高優先順位のタスクがタスクキ
 *  ューの末尾に移動した場合である．
 */
BOOL
rotate_ready_queue(UINT pri)
{
	QUEUE	*queue = &(ready_queue[pri]);
	QUEUE	*entry;

	if (!(queue_empty(queue)) && queue->next->next != queue) {
		entry = queue_delete_next(queue);
		queue_insert_prev(queue, entry);
		if (schedtsk == (TCB *) entry) {
			schedtsk = (TCB *)(queue->next);
			return(enadsp);
		}
	}
	return(FALSE);
}


＜kernel/queue.c＞----------------------------------------------------
/*
 *  キューの次エントリの取出し
 *
 *  queue の次エントリをキューから削除し，削除したエントリを返す．queue
 *  にキューヘッダを指定した場合には，キューの先頭のエントリを取り出す
 *  ことになる．queue に空のキューを指定して呼び出してはならない．
 */
Inline QUEUE *
queue_delete_next(QUEUE *queue)
{
	QUEUE	*entry;

	assert(queue->next != queue);
	entry = queue->next;
	queue->next = entry->next;
	entry->next->prev = queue;
	return(entry);
}

/*
 *  キューが空かどうかのチェック
 *
 *  queue にはキューヘッダを指定する．
 */
Inline BOOL
queue_empty(QUEUE *queue)
{
	if (queue->next == queue) {
		assert(queue->prev == queue);
		return(TRUE);
	}
	return(FALSE);
}

/*
 *  キューの前エントリへの挿入
 *
 *  queue の前に entry を挿入する．queue にキューヘッダを指定した場合
 *  には，キューの末尾に entry を挿入することになる．
 */
Inline void
queue_insert_prev(QUEUE *queue, QUEUE *entry)
{
	entry->prev = queue->prev;
	entry->next = queue;
	queue->prev->next = entry;
	queue->prev = entry;
}


＜kernel/task.h＞----------------------------------------------------
/*
 *  TCBのエリア（kernel_cfg.c）
 */
extern TCB	tcb_table[];

/*
 *  TCBからタスクIDを取り出すためのマクロ
 */
#define	TSKID(tcb)	(((tcb) - tcb_table) + TMIN_TSKID)


＜kernel/check.c＞----------------------------------------------------
/*
 *  呼出しコンテキストとCPUロック状態のチェック（E_CTX）
 */
#define CHECK_TSKCTX_UNL() {					\
	if (sense_context() || t_sense_lock()) {		\
		return(E_CTX);					\
	}							\
}

#define CHECK_INTCTX_UNL() {					\
	if (!sense_context() || i_sense_lock()) {		\
		return(E_CTX);					\
	}							\
}

/*
 *  タスク優先度のチェック（E_PAR）
 */
#define CHECK_TPRI_SELF(tpri) {					\
	if (!(VALID_TPRI(tpri) || (tpri) == TPRI_SELF)) {	\
		return(E_PAR);					\
	}							\
}

#define CHECK_TPRI(tpri) {					\
	if (!VALID_TPRI(tpri)) {				\
		return(E_PAR);					\
	}							\
}


＜config/sh3/cpu_config.h＞------------------------------------------
/*
 *  システム状態参照
 */

Inline BOOL
sense_context()
{
    UW  nest;
    Asm("stc r7_bank,%0":"=r"(nest));
        
	return(nest > 0);    
}


Inline BOOL
sense_lock()
{
	return(current_intmask() == MAX_IPM << 4);
}

#define t_sense_lock	sense_lock
#define i_sense_lock	sense_lock


/*
 *  CPU例外の発生した時のシステム状態の参照
 */

/*
 *  CPU例外の発生した時のコンテキスト判定
 */
Inline BOOL
exc_sense_context(VP p_excinf)
{
    UW  nest;
    Asm("stc r7_bank,%0":"=r"(nest));
        
	return(nest > 1);
}


/*
 *  CPU例外の発生した時のCPUロック状態の参照
 */
Inline BOOL
exc_sense_lock(VP p_excinf)
{
	return((*((UW *)p_excinf + 8) & 0x00000f0) == MAX_IPM << 4);
}


＜kernel/task.h＞---------------------------------------------
/*
 *  タスク初期化ブロック
 *
 *  タスクに関する情報を，値が変わらないためにROMに置ける部分（タスク
 *  初期化ブロック）と，値が変化するためにRAMに置かなければならない部
 *  分（タスクコントロールブロック，TCB）に分離し，TCB内に対応するタス
 *  ク初期化ブロックを指すポインタを入れる．タスク初期化ブロック内に対
 *  応するTCBを指すポインタを入れる方法の方が，RAMの節約の観点からは望
 *  ましいが，実行効率が悪くなるために採用していない．他のオブジェクト
 *  についても同様に扱う．
 *  タスク初期化ブロックには，DEF_TEX で定義されるタスク例外処理ルーチ
 *  ンに関する情報も含む．
 */
typedef struct task_initialization_block {
	ATR	tskatr;		/* タスク属性 */
	VP_INT	exinf;		/* タスクの拡張情報 */
	FP	task;		/* タスクの起動番地 */
	UINT	ipriority;	/* タスクの起動時優先度（内部表現） */
	SIZE	stksz;		/* スタック領域のサイズ（丸めた値） */
	VP	stk;		/* スタック領域の先頭番地 */

	ATR	texatr;		/* タスク例外処理ルーチン属性 */
	FP	texrtn;		/* タスク例外処理ルーチンの起動番地 */
} TINIB;


/*
 *  タスクコントロールブロック（TCB）
 *
 *  JSPでは，タスクの起動要求キューイング数の最大値（TMAX_ACTCNT）と起
 *  動要求キューイング数の最大値（TMAX_WUPCNT）は 1 に固定されているた
 *  め，キューイングされているかどうかの真偽値で表現することができる．
 *  また，強制待ち要求ネスト数の最大値（TMAX_SUSCNT）が 1 に固定されて
 *  いるので，強制待ち要求ネスト数（suscnt）は必要ない．
 */
typedef struct task_control_block {
	QUEUE	task_queue;	/* タスクキュー */
	const TINIB *tinib;	/* タスク初期化ブロックへのポインタ */

	UINT	tstat : TBIT_TCB_TSTAT;		/* タスク状態（内部表現）*/
	UINT	priority : TBIT_TCB_PRIORITY;	/* 現在の優先度（内部表現）*/
	BOOL	actcnt : 1;			/* 起動要求キューイング */
	BOOL	wupcnt : 1;			/* 起床要求キューイング */
	BOOL	enatex : 1;			/* タスク例外処理許可状態 */

	TEXPTN	texptn;		/* 保留例外要因 */
	WINFO	*winfo;		/* 待ち情報ブロックへのポインタ */
	CTXB	tskctxb;	/* タスクコンテキストブロック */
} TCB;


＜doc/configurator.txt＞---------------------------------------------
(4-2) 定義する割込みハンドラの数

定義する割込みハンドラの数をマクロ定義するプリプロセッサディレクティブ
（#define）を生成する．また，その値を持つ変数の定義を生成する．具体的
には，次のような行を生成する．

#define	TNUM_INHNO <定義する割込みハンドラの数>
const ID	tnum_inhno = TNUM_INHNO;


(4-4) 割込みハンドラ初期化ブロックの定義

割込みハンドラ初期化ブロックを生成する．具体的には，次のような行を生成
する．

const INHINIB inhinib_table[TNUM_INHNO] = {
	<割込みハンドラ 1 の初期化情報>,
	<割込みハンドラ 2 の初期化情報>,
		……
	<割込みハンドラ TNUM_INHNO の初期化情報>
};

この中の割込みハンドラの初期化情報は，次の形式とする．

	{ inhno, inhatr, INT_ENTRY(inthdr) }


＜include/kernel.h＞-------------------------------------------------
/*
 *  オブジェクト属性の定義
 */
#define TA_HLNG		0x00		/* 高級言語用インタフェース */
#define TA_ASM		0x01		/* アセンブリ言語用インタフェース */

#define TA_TFIFO	0x00		/* タスクの待ち行列をFIFO順に */
#define TA_TPRI		0x01		/* タスクの待ち行列を優先度順に */

#define TA_MFIFO	0x00		/* メッセージキューをFIFO順に */
#define TA_MPRI		0x02		/* メッセージキューを優先度順に */

#define TA_ACT		0x02		/* タスクを起動された状態で生成 */

#define TA_WSGL		0x00		/* イベントフラグの待ちタスクを1つに */
#define TA_CLR		0x04		/* イベントフラグのクリア指定 */

#define	TA_STA		0x02		/* 周期ハンドラを動作状態で生成 */


＜kernel/task.h＞----------------------------------------------------
/*
 *  タスク例外処理ルーチンの呼出し
 *
 *  実行状態のタスクの保留例外要因が 0 でなければ，タスク例外処理ルー
 *  チンを呼び出す．具体的には，実行状態のタスクの保留例外要因をクリア
 *  し，CPUロックを解除して，タスク例外処理ルーチンに分岐する．タスク
 *  例外処理ルーチンから戻ると，まずCPUロック状態に戻し，その間に保留
 *  例外要因が 0 でなくなっていれば，再びタスク例外処理ルーチンを呼び
 *  出す．実行中のタスクの保留例外要因が 0 の場合には，例外処理許可状
 *  態にして関数から戻る．
 *  この関数は，CPUロック状態で，runtsk->enatex を FALSE にして呼び出
 *  されることを想定している．ただし，runtsk->texptn が 0 の時は，
 *  runtsk->enatex が TRUE の状態で呼び出しても差し支えない．
 */
Inline void
call_texrtn()
{
	TEXPTN	texptn;

	while (runtsk->texptn != 0) {
		assert(runtsk->enatex == FALSE);
		texptn = runtsk->texptn;
		runtsk->texptn = 0;
		t_unlock_cpu();
		(*runtsk->tinib->texrtn)(texptn, runtsk->tinib->exinf);
		if (!t_sense_lock()) {
			t_lock_cpu();
		}
	}
	runtsk->enatex = TRUE;
}


＜sh3/cpu_config.h＞-------------------------------------------------
/*
 * 割り込みハンドラの疑似テーブル
 */
/**
 ** 例外コードの下5bitの0を削除して、配列のindexに対応させる。
 ** 7709Aの場合(INTEVT2)も考慮した結果、0x50にしてある。
 **/
FP  int_table[0x50];

Inline void
define_inh(INHNO inhno, FP inthdr)
{
        int_table[inhno >> 5] = inthdr;
#ifdef WITH_STUB
        Asm("mov #0x8,r0;  mov %0,r4; mov %1,r5; trapa #0x3f"
	    : /* no output */
	    : "r"(inhno),"r"(interrupt)
	    : "r0", "r4", "r5");
#endif
}


＜config/sh3/cpu_support.S＞-----------------------------------------
/*
 *  Exception 600 vector
 *  割り込みが発生すると実行される。		
 *
 *
 *  SH3は割り込みが発生するとすべてVBR+0x600番地からプログラムを実行するため、
 *  ここに配置するルーチンでまずスタックの切り替え、レジスタの保存,IPMの設定,
 *  割り込み要因の判定を行いその後BLビットを0にして割り込みハンドラを呼ぶ必要
 *  がある。
 *  割り込み要因に対応した割り込みハンドラの開始番地は配列int_table[]に登録し
 *  て呼び出す。オフセットの計算は、割り込み要因レジスタを右に2ビットシフトし
 *  て行う。割り込み要因レジスタはSH7708ではINVENTレジスタにセットされるが、
 *  SH7709およびSH7709AではINVENT2にセットされるため、ifdefにより切り分けてい
 *  る。また、一部のディバイスについて割り込み要因レジスタで渡される値とIPMと
 *  の間には関係がないため、各割り込み要因に対応したIPMを持つSRの内容を配列
 *  int_plevel_table[]に登録してそれを読み出す。
 *
 *  reqflg をチェックする前に割込みを禁止しないと，reqflg をチェック後
 *  に起動された割込みハンドラ内でディスパッチが要求された場合に，ディ
 *  スパッチされない．
 */
	.org	0x0600            /* _BASE_VBR + 0x0600番地に配置 */
	.align 2
	.global _interrupt
_interrupt:
	stc.l   spc,@-r15         /* 多重割り込みが入ると消えてしまうので */
	sts.l   pr,@-r15          /* spc,pr,ssr,r0〜r7をスタックに保存    */  
	stc.l   ssr,@-r15   
	stc.l   r0_bank,@-r15
	stc.l   r1_bank,@-r15
	stc.l   r2_bank,@-r15
	stc.l   r3_bank,@-r15
	stc.l   r4_bank,@-r15
	stc.l   r5_bank,@-r15
	stc.l   r6_bank,@-r15    
	stc.l   r7_bank,@-r15
	tst     r7,r7               /* 割り込み発生時のコンテキストを判定  */  
	bf/s    _interrupt_from_int /* 例外/割り込みハンドラならジャンプ   */
	add     #0x01,r7            /* 割り込みのネスト回数をインクリメント*/
	mov     r15,r1              /* スタックを入れ替え元のスタックポイ  */
	mov.l   _stacktop_k,r15	    /* ンタを保存                          */
	mov.l   r1,@-r15            
	mov.l   _intevt,r0          /* 例外要因レジスタを取得              */
	mov.l   @r0,r4              
	shlr2   r4                  /* 3ビット右シフトしオフセットを求める */
	shlr    r4                  
	mov.l   _int_plevel_table_k,r0 
	mov.l   @(r0,r4),r5         /* 割り込みの優先度を取得	           */
	mov.l   _int_table_k,r0    
	mov.l   @(r0,r4),r2         /* 割り込みハンドラのアドレスを取得    */
	ldc     r2,r2_bank	    /* バンク1に切り替えるためコピー       */	
	ldc     r5,sr               /* これ以降割り込みを受け付ける。      */
	jsr     @r2                 /* 割り込みハンドラへ                  */
	nop
	mov.l  _mask_md_ipm_ret,r0
	ldc    r0,sr	         /* 割り込み禁止                           */	
	stc    r7_bank,r7        /* 例外/割り込みのネスト回数をデクリメント*/
	dt     r7
	ldc    r7,r7_bank
	mov.l  _reqflg_k,r4      /* reqflgのチェック                       */
    mov.l  @r4,r1
	tst    r1,r1             /* reqflgがFALSEならret_to_task_intに飛ぶ */
	bt/s   _ret_to_task_int  /* タスクに戻る                           */
	mov.l  @r15,r15          /* 戻り先がタスクなのでスタックを戻す     */	
	xor    r0,r0
	mov.l  r0,@r4            /* reqflgをクリア	                   */
	bra    ret_int
	nop

_interrupt_from_int:
	mov.l   _intevt,r0             /* 例外要因INTEVT2レジスタを取得    */
	mov.l   @r0,r4
	shlr2   r4                     /* オフセットを求める               */
	shlr    r4                     /* オフセットを求める               */	
	mov.l   _int_plevel_table_k,r0 
	mov.l   @(r0,r4),r5            /* 割り込みの優先度を取得	   */
	mov.l   _int_table_k,r0        
	mov.l   @(r0,r4),r2            /* 割り込みハンドラのアドレスを取得 */
	ldc     r2,r2_bank             /* バンク1に切り替えるためコピー    */
	ldc     r5,sr                  /* これ以降割り込みを受け付ける。   */
	jsr     @r2                    /* 割り込みハンドラへ               */
	nop
	mov.l  _mask_md_ipm_ret,r0
	ldc    r0,sr	         /* 割り込み禁止                           */
	stc    r7_bank,r7        /* 例外/割り込みのネスト回数をデクリメント*/
	dt     r7
	ldc    r7,r7_bank
_ret_to_task_int:	         
	mov.l  @r15+,r7          /* r0〜r1,ssr,pr,spcを復帰し割り込み元に戻る */
	mov.l  @r15+,r6
	mov.l  @r15+,r5
	mov.l  @r15+,r4
	mov.l  @r15+,r3
	mov.l  @r15+,r2
	mov.l  @r15+,r1
	mov.l  @r15+,r0
	ldc.l  @r15+,ssr
	lds.l  @r15+,pr
	ldc.l  @r15+,spc
	rte
	nop
	.align  4
_stacktop_k:	
	.long  STACKTOP            /* タスク独立部のスタックの初期値  */
_intevt:		
#ifdef SH7708	
	.long  INTEVT
#else
	.long  INTEVT2
#endif	
_int_table_k:	
	.long    _int_table       
_int_plevel_table_k:	
	.long	_int_plevel_table 
_reqflg_k:
	.long  _reqflg
_mask_md_ipm_ret:	
	.long  0x40000000 + MAX_IPM << 4


/* 
 *  割り込みハンドラ/CPU例外ハンドラ出口処理
 *
 * 戻り先がタスクでreqflgがセットされている場合のみここにくる。
 * r7_bank = 0,割り込み禁止状態,スクラッチレジスタを保存した
 * 状態で呼び出すこと。 
 *	
 */
	.text
	.align 2
	.globl ret_int
	.globl ret_exc
ret_exc:
ret_int:
	mov.l  _runtsk_ret,r1   /* r0 <- runtsk                    */
	mov.l  @r1,r0           
	mov.l  _enadsp_ret,r2   /* enadspのチェック                */
	mov.l  @r2,r3
	tst    r3,r3           
	bt     ret_int_1           
	mov.l  _schedtsk_ret,r4 /* r5 <- schedtsk                  */ 
	mov.l  @r4,r5
	cmp/eq r0,r5            /* runtsk と schedtsk を比較       */
	bt     ret_int_1
    mov.l  r14,@-r15	/* 残りのレジスタを保存            */
    mov.l  r13,@-r15					
    mov.l  r12,@-r15					
    mov.l  r11,@-r15					
    mov.l  r10,@-r15					
    mov.l  r9,@-r15					
    mov.l  r8,@-r15
	sts.l  mach,@-r15					
	sts.l  macl,@-r15					
	stc.l  gbr,@-r15					
	mov    #TCB_sp,r1      /* タスクスタックを保存            */
	mov.l  r15,@(r0,r1)    
	mov.l  ret_int_r_k,r1  /* 実行再開番地を保存              */
	mov    #TCB_pc,r2	
	mov.l  r1,@(r0,r2)  
	bra    dispatcher_1        
	nop	
ret_int_r:
	ldc.l  @r15+,gbr       /* レジスタを復帰                  */
	lds.l  @r15+,macl
	lds.l  @r15+,mach
	mov.l  @r15+,r8		
	mov.l  @r15+,r9		
	mov.l  @r15+,r10		
	mov.l  @r15+,r11		
	mov.l  @r15+,r12		
	mov.l  @r15+,r13		
	mov.l  @r15+,r14		
ret_int_1:
	mov.l  _calltex_ret,r2    /* タスク例外処理ルーチン起動      */
	jsr    @r2             
	nop
#ifdef SUPPORT_CHG_IPM
	mov    #32,r0
	mov.l  @(r0,r15),r1
	mov.l  _unmask_ipm,r2
	and    r2,r1
	mov.l  _task_intmask_k,r2
	mov.l  @r2,r3
	or     r3,r1
	mov.l  r1,@(r0,r15)
#endif /* SUPPORT_CHG_IMP */
	mov.l  @r15+,r7       /* spc,pr,ssr,スクラッチレジスタを復帰 */
	mov.l  @r15+,r6        
	mov.l  @r15+,r5
	mov.l  @r15+,r4
	mov.l  @r15+,r3
	mov.l  @r15+,r2
	mov.l  @r15+,r1
	mov.l  @r15+,r0
	ldc.l  @r15+,ssr    
	lds.l  @r15+,pr
	ldc.l  @r15+,spc
	rte
	nop
	.align 4
_calltex_ret:	
	.long _calltex
_runtsk_ret:
	.long _runtsk
_schedtsk_ret:	
	.long _schedtsk
_enadsp_ret:	
	.long _enadsp
ret_int_r_k:
	.long ret_int_r


＜kernel/task.c＞----------------------------------------------------
/*
 *  タスク例外処理ルーチンの起動
 */
#ifndef OMIT_CALLTEX

void
calltex()
{
	if (runtsk->enatex) {
		runtsk->enatex = FALSE;
		call_texrtn();
	}
}

#endif /* OMIT_CALLTEX */


＜doc/configurator.txt＞---------------------------------------------

(5-2) 定義するCPU例外ハンドラの数

定義するCPU例外ハンドラの数をマクロ定義するプリプロセッサディレクティ
ブ（#define）を生成する．また，その値を持つ変数の定義を生成する．具体
的には，次のような行を生成する．

#define	TNUM_EXCNO <定義するCPU例外ハンドラの数>
const ID	tnum_excno = TNUM_EXCNO;

(5-4) CPU例外ハンドラ初期化ブロックの定義

CPU例外ハンドラ初期化ブロックを生成する．具体的には，次のような行を生
成する．

const EXCINIB excinib_table[TNUM_EXCNO] = {
	<CPU例外ハンドラ 1 の初期化情報>,
	<CPU例外ハンドラ 2 の初期化情報>,
		……
	<CPU例外ハンドラ TNUM_EXCNO の初期化情報>
};


(4-2) 定義する割込みハンドラの数

定義する割込みハンドラの数をマクロ定義するプリプロセッサディレクティブ
（#define）を生成する．また，その値を持つ変数の定義を生成する．具体的
には，次のような行を生成する．

#define	TNUM_INHNO <定義する割込みハンドラの数>
const ID	tnum_inhno = TNUM_INHNO;


＜config/sh3/cpu_config.c＞------------------------------------------

/*
 * CPU例外ハンドラの疑似テーブル
 */
/**
 ** 例外コード:例外イベント
 ** 0x040:TLBミス/TLB無効(ロード)
 ** 0x060:TLBミス/TLB無効(ストア)
 ** 0x080:初期ページ書きこみ
 ** ･･･
 ** 0x1E0:ユーザブレークポイントトラップ
 **/
FP	exc_table[(0x1E0 >> 5) + 1];

/*
 *   CPU例外ハンドラの設定
 *   擬似ベクターテーブルに登録
 */   

Inline void
define_exc(EXCNO excno, FP exchdr)
{
        exc_table[excno >> 5] = exchdr;
#ifdef WITH_STUB
        Asm("mov #0x8,r0;  mov %0,r4; mov %1,r5;  trapa #0x3f"
	    : /* no output */
	    : "r"(excno),"r"(general_exception)
	    : "r0", "r4", "r5");
#endif
}


＜config/sh3/cpu_support.S＞-----------------------------------------
/*
 *  Exception 100 vector
 *  アドレスエラー,スロット不当命令例外、Trapa例外等が発生すると実行される。
 *
 *  CPU例外ハンドラは、非タスクコンテキストで実行する、そのため、CPU例外ハン
 *  ドラを呼び出す前に例外/割り込みを示すレジスタバンク0の r7 レジスタをイン
 *  クメントし、リターンしてきた後にデクリメントする。CPU例外がタスクコンテキ
 *  ストで発生し、regflg が TRUE になった時に、 ret_exc へ分岐する。
 *  regflg をチェックする前に割り込みを禁止しないと、reqflg をチェック後に起
 *  動された割り込みハンドラ内でディスパッチが要求された場合に、ディスパッチ
 *  されない。
 *
 *		
 *  例外が発生すると、その例外が発生した番地をスキップするため、spcを2インク
 *  リメントする。次に例外発生元のコンテキストであるspc,pr,ssr,r0〜r7を退避
 *  する。例外が発生した時点でのコンテキストを調べ非タスクコンテキストなら
 *  _exception_from_intから実行を開始する。例外の要因はEXPEVTレジスタ読み、
 *  exc_tableからCPU例外ハンドラの開始番地を読み込む。発生した例外に対して
 *  CPU例外ハンドラが登録されていなければ、_no_reg_exceptionにブランチして、
 *  ssr,sr,spc,prの内容を出力して停止する。CPU例外ハンドラからリターンして
 *  きたら、reqflgを調べ0以外ならrec_exc()に飛び、0なら元の処理にリターンす
 *  る。
 *				 		
 */	
	.org	0x0100            /*  _BASE_VBR + 0x0400番地に配置  */
	.align 2
	.global _general_exception
_general_exception:
	stc    spc,r0             /* spcを2インクリメント            */
	add    #0x02,r0       
	mov.l  r0,@-r15           /* spc,pr,ssr をスタックに保存する */
	sts.l  pr,@-r15               
	stc.l  ssr,@-r15   
	stc.l  r0_bank,@-r15
	stc.l  r1_bank,@-r15
	stc.l  r2_bank,@-r15
	stc.l  r3_bank,@-r15
	stc.l  r4_bank,@-r15
	stc.l  r5_bank,@-r15
	stc.l  r6_bank,@-r15    
	stc.l  r7_bank,@-r15
	tst    r7,r7	         /* 例外発生元のコンテキストを判定            */
	bf/s   _exception_from_int /* 例外/割り込みハンドラならジャンプ       */
	add    #0x01,r7	         /* 例外/割り込みネスト回数をインクリメント   */
	mov    r15,r1            /* 戻り先が割り込みハンドラでないのでスタック*/
	mov.l  _stacktop_exc,r15 /* を入れ替え元のスタックポインタを保存      */  
	mov.l  r1,@-r15            
	mov.l  _expevt,r0        /* 割り込み許可すると消えるレジスタを保存    */
	mov.l  @r0,r5            /* EXPEVTレジスタを取得		              */
	ldc    r1,r4_bank        /* CPU例外ハンドラへの引数                   */
	ldc    r5,r5_bank	     
	mov.l  _unmak_rb_bl_exc,r2 /* BLビットを0に，レジスタバンクを切り替え */
	stc    sr,r3               
	and    r3,r2			
	ldc    r2,sr               
	shlr2  r5                /* EXPECTを3ビット右シフト	              */
	shlr   r5                
	mov.l  _exc_table_k,r0   /* exc_tableのアドレスをr0に                 */
	mov.l  @(r0,r5),r2       /* ハンドラのアドレスを取得                  */
	tst    r2,r2             /* ハンドラが登録されていない例外なら        */
	bt     _no_reg_exception /* no_reg_exceptionへジャンプ                */
	jsr    @r2               /* CPU例外ハンドラへ                         */
	nop
	mov.l  _mask_md_ipm_exc,r0
	ldc    r0,sr	         /* 割り込み禁止                              */
	stc    r7_bank,r7        /* 例外/割り込みのネスト回数をデクリメント   */
	dt     r7
	ldc    r7,r7_bank
	mov.l  _reqflg_exc,r2    /* reqflgのチェック                          */
	mov.l  @r2,r1
	tst    r1,r1             /* reqflgがFALSEならret_totask_excに飛び     */
	bt/s   _ret_to_task_exc  /* タスクに戻る                              */
	mov.l  @r15,r15          /* 戻り先がタスクなのでスタックを戻す        */
	xor    r0,r0	         /* reqflgをクリア                            */
	bra    ret_exc
	mov.l  r0,@r2              	


/*
 *   exception_from_int
 *   CPU例外発生時のコンテキストが非タスクコンテキストの場合の処理
 *   タスクコンテキストの場合との処理の違いは、とCPU例外ハンドラの
 *   処理が終了すると必ず元の処理に戻ることである。
 */
	
_exception_from_int:
	mov.l   _expevt,r0       /* 割り込み許可すると消えるレジスタを保存    */
	mov.l   @r0,r5           /* EXPECTレジスタを取得                      */
	ldc     r15,r4_bank      /* CPU例外ハンドラへの引数                   */
	ldc     r5,r5_bank	     
	mov.l   _unmak_rb_bl_exc,r2 /* BLビットを0に，レジスタバンクを切り替え */
	stc     sr,r3
	and     r3,r2			
	ldc     r2,sr               
	shlr2   r5               /* EXPECTを3ビット右シフト                   */
	shlr    r5                	
	mov.l   _exc_table_k,r0  /* exc_tableのアドレスをr0に                 */
	mov.l   @(r0,r5),r2      /* ハンドラのアドレスを取得                  */
	tst     r2,r2            /* ハンドラが登録されていない例外なら        */
	bt      _no_reg_exception   /* no_reg_exceptionへジャンプ             */
	jsr     @r2              /* CPU例外ハンドラへ                         */
	nop
	mov.l  _mask_md_ipm_exc,r0
	ldc    r0,sr	         /* 割り込み禁止                              */
	stc    r7_bank,r7        /* 例外/割り込みのネスト回数をデクリメント   */
	dt     r7
	ldc    r7,r7_bank
_ret_to_task_exc:		
	mov.l  @r15+,r7          /* r0〜r1,ssr,pr,spcを復帰しタスクに戻る     */
	mov.l  @r15+,r6
	mov.l  @r15+,r5
	mov.l  @r15+,r4
	mov.l  @r15+,r3
	mov.l  @r15+,r2
	mov.l  @r15+,r1
	mov.l  @r15+,r0
	ldc.l  @r15+,ssr            
	lds.l  @r15+,pr
	ldc.l  @r15+,spc
	rte
	nop


/*	
 *  no_reg_exception()
 *  CPU例外として登録されていない例外が発生すると呼び出される
 *  例外コード、例外が発生した時点のpc,sr,prを出力してカーネル
 *  を停止する。
 */					
_no_reg_exception:
	mov.l  _expevt,r5
	mov.l  @r5,r4
	stc    spc,r5
	stc    ssr,r6
	sts    pr,r7
	mov.l  _cpu_expevt_k,r1
	jsr    @r1
	nop

	.align  4
_stacktop_exc:	
	.long  STACKTOP            /* タスク独立部のスタックの初期値  */
_expevt:	
	.long  EXPEVT
_exc_table_k:	
	.long  _exc_table
_unmak_rb_bl_exc:		
	.long  0x4fffffff
_mask_md_ipm_exc:	
	.long  0x40000000 + MAX_IPM << 4	
_reqflg_exc:
	.long  _reqflg
_cpu_expevt_k:	
	.long  _cpu_expevt	



＜MS7709ASE01/sample1.c＞--------------------------------------------
/*
 *  CPUロードアドレスエラーハンドラ
 */  
void
LoadAddressError_handler(VP p_excinf)
{
	ID	tskid;
/*	VW	*frame = p_excinf; */

	syslog(LOG_NOTICE, "Load Error Stack Frame: %08x",p_excinf);
	syslog(LOG_NOTICE,
		"vxsns_loc = %d vxsns_ctx = %d vxsns_dsp = %d vxsns_dpn = %d",
		vxsns_loc(p_excinf), vxsns_ctx(p_excinf),
		vxsns_dsp(p_excinf), vxsns_dpn(p_excinf));
	if (!vxsns_loc(p_excinf) && !vxsns_ctx(p_excinf)) {
		syscall(iget_tid(&tskid));
		syscall(iras_tex(tskid, 0x8000));
	}
}


＜doc/sh3.txt＞------------------------------------------------------
CPU例外ハンドラに渡されるp_excinfは，CPU例外発生時のコンテキストを保存
したスタックへのポインタが渡される．スタックの構造を以下に示す．

      ----------------------
     |         R7           |  <-- p_excinf
      ----------------------
     |         R6           |
      ----------------------
     |         R5           |
      ----------------------
     |         R4           |
      ----------------------
     |         R3           |
      ----------------------
     |         R2           |
      ----------------------
     |         R1           |
      ----------------------
     |         R0           |
      ----------------------
     |         SR           |
      ----------------------
     |         PR           |
      ----------------------
     |         PC           |
      ----------------------

